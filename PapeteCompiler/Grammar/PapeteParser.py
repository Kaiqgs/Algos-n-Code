# Generated from Grammar/Papete.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\65")
        buf.write("\u01a4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\3\2\3\2\3\2\3\2\6\2\61")
        buf.write("\n\2\r\2\16\2\62\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write("\2\5\2?\n\2\3\3\3\3\3\3\3\3\5\3E\n\3\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\5\4N\n\4\6\4P\n\4\r\4\16\4Q\3\4\5\4U\n\4\3")
        buf.write("\4\3\4\3\4\6\4Z\n\4\r\4\16\4[\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\5\4h\n\4\6\4j\n\4\r\4\16\4k\3\4\5\4o")
        buf.write("\n\4\3\4\3\4\3\4\6\4t\n\4\r\4\16\4u\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\6\4\u0081\n\4\r\4\16\4\u0082\3\4\3")
        buf.write("\4\3\4\3\4\3\4\5\4\u008a\n\4\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5\u009e")
        buf.write("\n\5\3\6\3\6\3\6\3\6\5\6\u00a4\n\6\6\6\u00a6\n\6\r\6\16")
        buf.write("\6\u00a7\3\6\3\6\3\6\3\6\5\6\u00ae\n\6\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\6\7\u00b6\n\7\r\7\16\7\u00b7\3\7\3\7\3\b\3\b")
        buf.write("\3\b\3\b\5\b\u00c0\n\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\6\b")
        buf.write("\u00c9\n\b\r\b\16\b\u00ca\3\b\3\b\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\6\t\u00d5\n\t\r\t\16\t\u00d6\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\5\t\u00e0\n\t\3\t\3\t\3\t\6\t\u00e5\n\t\r\t\16")
        buf.write("\t\u00e6\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\6\t\u00f1\n\t")
        buf.write("\r\t\16\t\u00f2\3\t\3\t\3\t\3\t\6\t\u00f9\n\t\r\t\16\t")
        buf.write("\u00fa\3\t\3\t\5\t\u00ff\n\t\3\n\3\n\3\n\3\n\3\n\3\n\7")
        buf.write("\n\u0107\n\n\f\n\16\n\u010a\13\n\3\13\3\13\3\13\3\13\3")
        buf.write("\13\3\13\7\13\u0112\n\13\f\13\16\13\u0115\13\13\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u011f\n\f\3\r\3\r\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\5\16\u0129\n\16\3\17\3\17\3")
        buf.write("\17\5\17\u012e\n\17\3\17\3\17\5\17\u0132\n\17\3\17\5\17")
        buf.write("\u0135\n\17\6\17\u0137\n\17\r\17\16\17\u0138\3\17\3\17")
        buf.write("\3\17\3\17\3\17\5\17\u0140\n\17\3\20\3\20\3\20\3\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\3\21\5\21\u014c\n\21\3\22\3\22")
        buf.write("\3\22\3\22\3\22\5\22\u0153\n\22\3\22\3\22\3\22\3\22\3")
        buf.write("\22\5\22\u015a\n\22\3\22\3\22\3\22\3\22\3\22\5\22\u0161")
        buf.write("\n\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u016b")
        buf.write("\n\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u0173\n\22\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\7\23\u017e")
        buf.write("\n\23\f\23\16\23\u0181\13\23\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\24\3\24\3\24\7\24\u018f\n\24\f")
        buf.write("\24\16\24\u0192\13\24\3\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\5\25\u019b\n\25\3\26\3\26\3\26\3\26\3\26\5\26\u01a2")
        buf.write("\n\26\3\26\2\6\22\24$&\27\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write("\32\34\36 \"$&(*\2\7\4\2!!%%\4\2..\60\61\3\2\25\32\3\2")
        buf.write("\21\22\4\2\5\5\61\61\2\u01d3\2>\3\2\2\2\4D\3\2\2\2\6\u0089")
        buf.write("\3\2\2\2\b\u009d\3\2\2\2\n\u00ad\3\2\2\2\f\u00af\3\2\2")
        buf.write("\2\16\u00bb\3\2\2\2\20\u00fe\3\2\2\2\22\u0100\3\2\2\2")
        buf.write("\24\u010b\3\2\2\2\26\u011e\3\2\2\2\30\u0120\3\2\2\2\32")
        buf.write("\u0128\3\2\2\2\34\u013f\3\2\2\2\36\u0141\3\2\2\2 \u014b")
        buf.write("\3\2\2\2\"\u0172\3\2\2\2$\u0174\3\2\2\2&\u0182\3\2\2\2")
        buf.write("(\u019a\3\2\2\2*\u01a1\3\2\2\2,-\5\4\3\2-.\7+\2\2.\61")
        buf.write("\3\2\2\2/\61\5\6\4\2\60,\3\2\2\2\60/\3\2\2\2\61\62\3\2")
        buf.write("\2\2\62\60\3\2\2\2\62\63\3\2\2\2\63\64\3\2\2\2\64\65\7")
        buf.write("\2\2\3\65?\3\2\2\2\66\67\7\20\2\2\678\7\26\2\289\7.\2")
        buf.write("\29:\7\3\2\2:;\7\17\2\2;<\7\25\2\2<=\7+\2\2=?\5\2\2\2")
        buf.write(">\60\3\2\2\2>\66\3\2\2\2?\3\3\2\2\2@E\5\"\22\2AE\5\34")
        buf.write("\17\2BE\5\36\20\2CE\5\n\6\2D@\3\2\2\2DA\3\2\2\2DB\3\2")
        buf.write("\2\2DC\3\2\2\2E\5\3\2\2\2FG\5*\26\2GH\7.\2\2HT\7\4\2\2")
        buf.write("IJ\5*\26\2JK\7.\2\2KM\3\2\2\2LN\7+\2\2ML\3\2\2\2MN\3\2")
        buf.write("\2\2NP\3\2\2\2OI\3\2\2\2PQ\3\2\2\2QO\3\2\2\2QR\3\2\2\2")
        buf.write("RU\3\2\2\2SU\7\5\2\2TO\3\2\2\2TS\3\2\2\2UV\3\2\2\2VW\7")
        buf.write("\6\2\2WY\7)\2\2XZ\5\b\5\2YX\3\2\2\2Z[\3\2\2\2[Y\3\2\2")
        buf.write("\2[\\\3\2\2\2\\]\3\2\2\2]^\5 \21\2^_\7*\2\2_\u008a\3\2")
        buf.write("\2\2`a\7%\2\2ab\7.\2\2bn\7\4\2\2cd\5*\26\2de\7.\2\2eg")
        buf.write("\3\2\2\2fh\7+\2\2gf\3\2\2\2gh\3\2\2\2hj\3\2\2\2ic\3\2")
        buf.write("\2\2jk\3\2\2\2ki\3\2\2\2kl\3\2\2\2lo\3\2\2\2mo\7\5\2\2")
        buf.write("ni\3\2\2\2nm\3\2\2\2op\3\2\2\2pq\7\6\2\2qs\7)\2\2rt\5")
        buf.write("\b\5\2sr\3\2\2\2tu\3\2\2\2us\3\2\2\2uv\3\2\2\2vw\3\2\2")
        buf.write("\2wx\7*\2\2x\u008a\3\2\2\2yz\t\2\2\2z{\7 \2\2{|\7\4\2")
        buf.write("\2|}\7\5\2\2}~\7\6\2\2~\u0080\7)\2\2\177\u0081\5\b\5\2")
        buf.write("\u0080\177\3\2\2\2\u0081\u0082\3\2\2\2\u0082\u0080\3\2")
        buf.write("\2\2\u0082\u0083\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u0085")
        buf.write("\7(\2\2\u0085\u0086\7\5\2\2\u0086\u0087\7+\2\2\u0087\u0088")
        buf.write("\7*\2\2\u0088\u008a\3\2\2\2\u0089F\3\2\2\2\u0089`\3\2")
        buf.write("\2\2\u0089y\3\2\2\2\u008a\7\3\2\2\2\u008b\u008c\5\"\22")
        buf.write("\2\u008c\u008d\7+\2\2\u008d\u009e\3\2\2\2\u008e\u008f")
        buf.write("\5\36\20\2\u008f\u0090\7+\2\2\u0090\u009e\3\2\2\2\u0091")
        buf.write("\u0092\5\34\17\2\u0092\u0093\7+\2\2\u0093\u009e\3\2\2")
        buf.write("\2\u0094\u0095\5\32\16\2\u0095\u0096\7+\2\2\u0096\u009e")
        buf.write("\3\2\2\2\u0097\u009e\5\20\t\2\u0098\u009e\5\f\7\2\u0099")
        buf.write("\u009e\5\16\b\2\u009a\u009b\5\n\6\2\u009b\u009c\7+\2\2")
        buf.write("\u009c\u009e\3\2\2\2\u009d\u008b\3\2\2\2\u009d\u008e\3")
        buf.write("\2\2\2\u009d\u0091\3\2\2\2\u009d\u0094\3\2\2\2\u009d\u0097")
        buf.write("\3\2\2\2\u009d\u0098\3\2\2\2\u009d\u0099\3\2\2\2\u009d")
        buf.write("\u009a\3\2\2\2\u009e\t\3\2\2\2\u009f\u00a0\7.\2\2\u00a0")
        buf.write("\u00a5\7\4\2\2\u00a1\u00a3\t\3\2\2\u00a2\u00a4\7\7\2\2")
        buf.write("\u00a3\u00a2\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6\3")
        buf.write("\2\2\2\u00a5\u00a1\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a5")
        buf.write("\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9")
        buf.write("\u00ae\7\6\2\2\u00aa\u00ab\7.\2\2\u00ab\u00ac\7\4\2\2")
        buf.write("\u00ac\u00ae\7\6\2\2\u00ad\u009f\3\2\2\2\u00ad\u00aa\3")
        buf.write("\2\2\2\u00ae\13\3\2\2\2\u00af\u00b0\7\24\2\2\u00b0\u00b1")
        buf.write("\7\4\2\2\u00b1\u00b2\5\22\n\2\u00b2\u00b3\7\6\2\2\u00b3")
        buf.write("\u00b5\7)\2\2\u00b4\u00b6\5\b\5\2\u00b5\u00b4\3\2\2\2")
        buf.write("\u00b6\u00b7\3\2\2\2\u00b7\u00b5\3\2\2\2\u00b7\u00b8\3")
        buf.write("\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u00ba\7*\2\2\u00ba\r")
        buf.write("\3\2\2\2\u00bb\u00bc\7\23\2\2\u00bc\u00bf\7\4\2\2\u00bd")
        buf.write("\u00c0\5\"\22\2\u00be\u00c0\5\36\20\2\u00bf\u00bd\3\2")
        buf.write("\2\2\u00bf\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\u00c2")
        buf.write("\7+\2\2\u00c2\u00c3\5\22\n\2\u00c3\u00c4\7+\2\2\u00c4")
        buf.write("\u00c5\5\"\22\2\u00c5\u00c6\7\6\2\2\u00c6\u00c8\7)\2\2")
        buf.write("\u00c7\u00c9\5\b\5\2\u00c8\u00c7\3\2\2\2\u00c9\u00ca\3")
        buf.write("\2\2\2\u00ca\u00c8\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb\u00cc")
        buf.write("\3\2\2\2\u00cc\u00cd\7*\2\2\u00cd\17\3\2\2\2\u00ce\u00cf")
        buf.write("\7\34\2\2\u00cf\u00d0\7\4\2\2\u00d0\u00d1\5\22\n\2\u00d1")
        buf.write("\u00d2\7\6\2\2\u00d2\u00d4\7)\2\2\u00d3\u00d5\5\b\5\2")
        buf.write("\u00d4\u00d3\3\2\2\2\u00d5\u00d6\3\2\2\2\u00d6\u00d4\3")
        buf.write("\2\2\2\u00d6\u00d7\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\u00d9")
        buf.write("\7*\2\2\u00d9\u00ff\3\2\2\2\u00da\u00db\7\34\2\2\u00db")
        buf.write("\u00df\7\4\2\2\u00dc\u00e0\7.\2\2\u00dd\u00de\7\b\2\2")
        buf.write("\u00de\u00e0\7.\2\2\u00df\u00dc\3\2\2\2\u00df\u00dd\3")
        buf.write("\2\2\2\u00e0\u00e1\3\2\2\2\u00e1\u00e2\7\6\2\2\u00e2\u00e4")
        buf.write("\7)\2\2\u00e3\u00e5\5\b\5\2\u00e4\u00e3\3\2\2\2\u00e5")
        buf.write("\u00e6\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6\u00e7\3\2\2\2")
        buf.write("\u00e7\u00e8\3\2\2\2\u00e8\u00e9\7*\2\2\u00e9\u00ff\3")
        buf.write("\2\2\2\u00ea\u00eb\7\34\2\2\u00eb\u00ec\7\4\2\2\u00ec")
        buf.write("\u00ed\5\22\n\2\u00ed\u00ee\7\6\2\2\u00ee\u00f0\7)\2\2")
        buf.write("\u00ef\u00f1\5\b\5\2\u00f0\u00ef\3\2\2\2\u00f1\u00f2\3")
        buf.write("\2\2\2\u00f2\u00f0\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3\u00f4")
        buf.write("\3\2\2\2\u00f4\u00f5\7*\2\2\u00f5\u00f6\7\36\2\2\u00f6")
        buf.write("\u00f8\7)\2\2\u00f7\u00f9\5\b\5\2\u00f8\u00f7\3\2\2\2")
        buf.write("\u00f9\u00fa\3\2\2\2\u00fa\u00f8\3\2\2\2\u00fa\u00fb\3")
        buf.write("\2\2\2\u00fb\u00fc\3\2\2\2\u00fc\u00fd\7*\2\2\u00fd\u00ff")
        buf.write("\3\2\2\2\u00fe\u00ce\3\2\2\2\u00fe\u00da\3\2\2\2\u00fe")
        buf.write("\u00ea\3\2\2\2\u00ff\21\3\2\2\2\u0100\u0101\b\n\1\2\u0101")
        buf.write("\u0102\5\24\13\2\u0102\u0108\3\2\2\2\u0103\u0104\f\4\2")
        buf.write("\2\u0104\u0105\7\33\2\2\u0105\u0107\5\24\13\2\u0106\u0103")
        buf.write("\3\2\2\2\u0107\u010a\3\2\2\2\u0108\u0106\3\2\2\2\u0108")
        buf.write("\u0109\3\2\2\2\u0109\23\3\2\2\2\u010a\u0108\3\2\2\2\u010b")
        buf.write("\u010c\b\13\1\2\u010c\u010d\5\26\f\2\u010d\u0113\3\2\2")
        buf.write("\2\u010e\u010f\f\4\2\2\u010f\u0110\7\35\2\2\u0110\u0112")
        buf.write("\5\26\f\2\u0111\u010e\3\2\2\2\u0112\u0115\3\2\2\2\u0113")
        buf.write("\u0111\3\2\2\2\u0113\u0114\3\2\2\2\u0114\25\3\2\2\2\u0115")
        buf.write("\u0113\3\2\2\2\u0116\u0117\5$\23\2\u0117\u0118\5\30\r")
        buf.write("\2\u0118\u0119\5$\23\2\u0119\u011f\3\2\2\2\u011a\u011b")
        buf.write("\7\4\2\2\u011b\u011c\5\22\n\2\u011c\u011d\7\6\2\2\u011d")
        buf.write("\u011f\3\2\2\2\u011e\u0116\3\2\2\2\u011e\u011a\3\2\2\2")
        buf.write("\u011f\27\3\2\2\2\u0120\u0121\t\4\2\2\u0121\31\3\2\2\2")
        buf.write("\u0122\u0123\7\'\2\2\u0123\u0129\7.\2\2\u0124\u0125\7")
        buf.write("\'\2\2\u0125\u0126\5*\26\2\u0126\u0127\7.\2\2\u0127\u0129")
        buf.write("\3\2\2\2\u0128\u0122\3\2\2\2\u0128\u0124\3\2\2\2\u0129")
        buf.write("\33\3\2\2\2\u012a\u012b\7\37\2\2\u012b\u0136\7\4\2\2\u012c")
        buf.write("\u012e\7\t\2\2\u012d\u012c\3\2\2\2\u012d\u012e\3\2\2\2")
        buf.write("\u012e\u012f\3\2\2\2\u012f\u0131\7-\2\2\u0130\u0132\7")
        buf.write("\t\2\2\u0131\u0130\3\2\2\2\u0131\u0132\3\2\2\2\u0132\u0134")
        buf.write("\3\2\2\2\u0133\u0135\7.\2\2\u0134\u0133\3\2\2\2\u0134")
        buf.write("\u0135\3\2\2\2\u0135\u0137\3\2\2\2\u0136\u012d\3\2\2\2")
        buf.write("\u0137\u0138\3\2\2\2\u0138\u0136\3\2\2\2\u0138\u0139\3")
        buf.write("\2\2\2\u0139\u013a\3\2\2\2\u013a\u0140\7\6\2\2\u013b\u013c")
        buf.write("\7\37\2\2\u013c\u013d\7\4\2\2\u013d\u013e\7.\2\2\u013e")
        buf.write("\u0140\7\6\2\2\u013f\u012a\3\2\2\2\u013f\u013b\3\2\2\2")
        buf.write("\u0140\35\3\2\2\2\u0141\u0142\5*\26\2\u0142\u0143\7.\2")
        buf.write("\2\u0143\37\3\2\2\2\u0144\u0145\7(\2\2\u0145\u0146\7.")
        buf.write("\2\2\u0146\u014c\7+\2\2\u0147\u0148\7(\2\2\u0148\u0149")
        buf.write("\5$\23\2\u0149\u014a\7+\2\2\u014a\u014c\3\2\2\2\u014b")
        buf.write("\u0144\3\2\2\2\u014b\u0147\3\2\2\2\u014c!\3\2\2\2\u014d")
        buf.write("\u014e\7!\2\2\u014e\u014f\7.\2\2\u014f\u0152\7\n\2\2\u0150")
        buf.write("\u0153\5$\23\2\u0151\u0153\5\n\6\2\u0152\u0150\3\2\2\2")
        buf.write("\u0152\u0151\3\2\2\2\u0153\u0173\3\2\2\2\u0154\u0155\7")
        buf.write("#\2\2\u0155\u0156\7.\2\2\u0156\u0159\7\n\2\2\u0157\u015a")
        buf.write("\5$\23\2\u0158\u015a\5\n\6\2\u0159\u0157\3\2\2\2\u0159")
        buf.write("\u0158\3\2\2\2\u015a\u0173\3\2\2\2\u015b\u015c\7$\2\2")
        buf.write("\u015c\u015d\7.\2\2\u015d\u0160\7\n\2\2\u015e\u0161\7")
        buf.write("-\2\2\u015f\u0161\5\n\6\2\u0160\u015e\3\2\2\2\u0160\u015f")
        buf.write("\3\2\2\2\u0161\u0173\3\2\2\2\u0162\u0163\7&\2\2\u0163")
        buf.write("\u0164\7.\2\2\u0164\u0165\7\n\2\2\u0165\u0173\t\5\2\2")
        buf.write("\u0166\u0167\7.\2\2\u0167\u016a\7\n\2\2\u0168\u016b\5")
        buf.write("$\23\2\u0169\u016b\5\n\6\2\u016a\u0168\3\2\2\2\u016a\u0169")
        buf.write("\3\2\2\2\u016b\u0173\3\2\2\2\u016c\u016d\7.\2\2\u016d")
        buf.write("\u016e\7\n\2\2\u016e\u0173\7-\2\2\u016f\u0170\7.\2\2\u0170")
        buf.write("\u0171\7\n\2\2\u0171\u0173\t\5\2\2\u0172\u014d\3\2\2\2")
        buf.write("\u0172\u0154\3\2\2\2\u0172\u015b\3\2\2\2\u0172\u0162\3")
        buf.write("\2\2\2\u0172\u0166\3\2\2\2\u0172\u016c\3\2\2\2\u0172\u016f")
        buf.write("\3\2\2\2\u0173#\3\2\2\2\u0174\u0175\b\23\1\2\u0175\u0176")
        buf.write("\5&\24\2\u0176\u017f\3\2\2\2\u0177\u0178\f\4\2\2\u0178")
        buf.write("\u0179\7\t\2\2\u0179\u017e\5&\24\2\u017a\u017b\f\3\2\2")
        buf.write("\u017b\u017c\7\13\2\2\u017c\u017e\5&\24\2\u017d\u0177")
        buf.write("\3\2\2\2\u017d\u017a\3\2\2\2\u017e\u0181\3\2\2\2\u017f")
        buf.write("\u017d\3\2\2\2\u017f\u0180\3\2\2\2\u0180%\3\2\2\2\u0181")
        buf.write("\u017f\3\2\2\2\u0182\u0183\b\24\1\2\u0183\u0184\5(\25")
        buf.write("\2\u0184\u0190\3\2\2\2\u0185\u0186\f\5\2\2\u0186\u0187")
        buf.write("\7\f\2\2\u0187\u018f\5(\25\2\u0188\u0189\f\4\2\2\u0189")
        buf.write("\u018a\7\r\2\2\u018a\u018f\5(\25\2\u018b\u018c\f\3\2\2")
        buf.write("\u018c\u018d\7\16\2\2\u018d\u018f\5(\25\2\u018e\u0185")
        buf.write("\3\2\2\2\u018e\u0188\3\2\2\2\u018e\u018b\3\2\2\2\u018f")
        buf.write("\u0192\3\2\2\2\u0190\u018e\3\2\2\2\u0190\u0191\3\2\2\2")
        buf.write("\u0191\'\3\2\2\2\u0192\u0190\3\2\2\2\u0193\u019b\7.\2")
        buf.write("\2\u0194\u019b\7\60\2\2\u0195\u019b\t\6\2\2\u0196\u0197")
        buf.write("\7\4\2\2\u0197\u0198\5$\23\2\u0198\u0199\7\6\2\2\u0199")
        buf.write("\u019b\3\2\2\2\u019a\u0193\3\2\2\2\u019a\u0194\3\2\2\2")
        buf.write("\u019a\u0195\3\2\2\2\u019a\u0196\3\2\2\2\u019b)\3\2\2")
        buf.write("\2\u019c\u01a2\7!\2\2\u019d\u01a2\7#\2\2\u019e\u01a2\7")
        buf.write("\"\2\2\u019f\u01a2\7$\2\2\u01a0\u01a2\7&\2\2\u01a1\u019c")
        buf.write("\3\2\2\2\u01a1\u019d\3\2\2\2\u01a1\u019e\3\2\2\2\u01a1")
        buf.write("\u019f\3\2\2\2\u01a1\u01a0\3\2\2\2\u01a2+\3\2\2\2\62\60")
        buf.write("\62>DMQT[gknu\u0082\u0089\u009d\u00a3\u00a7\u00ad\u00b7")
        buf.write("\u00bf\u00ca\u00d6\u00df\u00e6\u00f2\u00fa\u00fe\u0108")
        buf.write("\u0113\u011e\u0128\u012d\u0131\u0134\u0138\u013f\u014b")
        buf.write("\u0152\u0159\u0160\u016a\u0172\u017d\u017f\u018e\u0190")
        buf.write("\u019a\u01a1")
        return buf.getvalue()


class PapeteParser ( Parser ):

    grammarFileName = "Papete.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "'('", "'0'", "')'", "','", "'!'", 
                     "'+'", "'='", "'-'", "'*'", "'/'", "'%'", "'gramaticaextensao'", 
                     "'import'", "'true'", "'false'", "'for'", "'while'", 
                     "'>'", "'<'", "'>='", "'<='", "'=='", "'!='", "'||'", 
                     "'if'", "'&&'", "'else'", "'print'", "'main'", "'int'", 
                     "'float'", "'double'", "'string'", "'void'", "'boolean'", 
                     "'read'", "'return'", "'{'", "'}'", "';'", "'global'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "GRAMATICA", "IMPORT", "TRUE", "FALSE", 
                      "FOR", "WHILE", "GRT", "LESS", "GRTEQ", "LESSEQ", 
                      "EQ", "NEQ", "OR", "IF", "AND", "ELSE", "PRINT", "MAIN", 
                      "INT", "FLOAT", "DOUBLE", "STRING", "VOID", "BOOL", 
                      "READ", "RET", "OBR", "CBR", "EOL", "GLOBAL", "STRVALUE", 
                      "VAR", "PRINTCONC", "NUMDOUBLE", "NUMINT", "COMMENT", 
                      "LINE_COMMENT", "WS", "COM" ]

    RULE_prog = 0
    RULE_line = 1
    RULE_func = 2
    RULE_cmd = 3
    RULE_callfunc = 4
    RULE_while_ = 5
    RULE_for_ = 6
    RULE_ifstmt = 7
    RULE_cond = 8
    RULE_cdand = 9
    RULE_cndts = 10
    RULE_relop = 11
    RULE_read = 12
    RULE_print_ = 13
    RULE_init_ = 14
    RULE_retr = 15
    RULE_atr = 16
    RULE_expr = 17
    RULE_term = 18
    RULE_fact = 19
    RULE_type_ = 20

    ruleNames =  [ "prog", "line", "func", "cmd", "callfunc", "while_", 
                   "for_", "ifstmt", "cond", "cdand", "cndts", "relop", 
                   "read", "print_", "init_", "retr", "atr", "expr", "term", 
                   "fact", "type_" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    GRAMATICA=13
    IMPORT=14
    TRUE=15
    FALSE=16
    FOR=17
    WHILE=18
    GRT=19
    LESS=20
    GRTEQ=21
    LESSEQ=22
    EQ=23
    NEQ=24
    OR=25
    IF=26
    AND=27
    ELSE=28
    PRINT=29
    MAIN=30
    INT=31
    FLOAT=32
    DOUBLE=33
    STRING=34
    VOID=35
    BOOL=36
    READ=37
    RET=38
    OBR=39
    CBR=40
    EOL=41
    GLOBAL=42
    STRVALUE=43
    VAR=44
    PRINTCONC=45
    NUMDOUBLE=46
    NUMINT=47
    COMMENT=48
    LINE_COMMENT=49
    WS=50
    COM=51

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(PapeteParser.EOF, 0)

        def line(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.LineContext)
            else:
                return self.getTypedRuleContext(PapeteParser.LineContext,i)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.EOL)
            else:
                return self.getToken(PapeteParser.EOL, i)

        def func(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.FuncContext)
            else:
                return self.getTypedRuleContext(PapeteParser.FuncContext,i)


        def IMPORT(self):
            return self.getToken(PapeteParser.IMPORT, 0)

        def LESS(self):
            return self.getToken(PapeteParser.LESS, 0)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)

        def GRAMATICA(self):
            return self.getToken(PapeteParser.GRAMATICA, 0)

        def GRT(self):
            return self.getToken(PapeteParser.GRT, 0)

        def prog(self):
            return self.getTypedRuleContext(PapeteParser.ProgContext,0)


        def getRuleIndex(self):
            return PapeteParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = PapeteParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.state = 60
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PapeteParser.PRINT, PapeteParser.INT, PapeteParser.FLOAT, PapeteParser.DOUBLE, PapeteParser.STRING, PapeteParser.VOID, PapeteParser.BOOL, PapeteParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 46 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 46
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        self.state = 42
                        self.line()
                        self.state = 43
                        self.match(PapeteParser.EOL)
                        pass

                    elif la_ == 2:
                        self.state = 45
                        self.func()
                        pass


                    self.state = 48 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.VOID) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 50
                self.match(PapeteParser.EOF)
                pass
            elif token in [PapeteParser.IMPORT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 52
                self.match(PapeteParser.IMPORT)
                self.state = 53
                self.match(PapeteParser.LESS)
                self.state = 54
                self.match(PapeteParser.VAR)
                self.state = 55
                self.match(PapeteParser.T__0)
                self.state = 56
                self.match(PapeteParser.GRAMATICA)
                self.state = 57
                self.match(PapeteParser.GRT)
                self.state = 58
                self.match(PapeteParser.EOL)
                self.state = 59
                self.prog()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_line

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AtrLineContext(LineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.LineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atr(self):
            return self.getTypedRuleContext(PapeteParser.AtrContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtrLine" ):
                listener.enterAtrLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtrLine" ):
                listener.exitAtrLine(self)


    class InitLineContext(LineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.LineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def init_(self):
            return self.getTypedRuleContext(PapeteParser.Init_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitLine" ):
                listener.enterInitLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitLine" ):
                listener.exitInitLine(self)


    class PrintLineContext(LineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.LineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def print_(self):
            return self.getTypedRuleContext(PapeteParser.Print_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintLine" ):
                listener.enterPrintLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintLine" ):
                listener.exitPrintLine(self)


    class CallFuncLineContext(LineContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.LineContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallFuncLine" ):
                listener.enterCallFuncLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallFuncLine" ):
                listener.exitCallFuncLine(self)



    def line(self):

        localctx = PapeteParser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_line)
        try:
            self.state = 66
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.AtrLineContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 62
                self.atr()
                pass

            elif la_ == 2:
                localctx = PapeteParser.PrintLineContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 63
                self.print_()
                pass

            elif la_ == 3:
                localctx = PapeteParser.InitLineContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 64
                self.init_()
                pass

            elif la_ == 4:
                localctx = PapeteParser.CallFuncLineContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 65
                self.callfunc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.Type_Context)
            else:
                return self.getTypedRuleContext(PapeteParser.Type_Context,i)


        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.VAR)
            else:
                return self.getToken(PapeteParser.VAR, i)

        def OBR(self):
            return self.getToken(PapeteParser.OBR, 0)

        def retr(self):
            return self.getTypedRuleContext(PapeteParser.RetrContext,0)


        def CBR(self):
            return self.getToken(PapeteParser.CBR, 0)

        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.EOL)
            else:
                return self.getToken(PapeteParser.EOL, i)

        def VOID(self):
            return self.getToken(PapeteParser.VOID, 0)

        def MAIN(self):
            return self.getToken(PapeteParser.MAIN, 0)

        def RET(self):
            return self.getToken(PapeteParser.RET, 0)

        def INT(self):
            return self.getToken(PapeteParser.INT, 0)

        def getRuleIndex(self):
            return PapeteParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)




    def func(self):

        localctx = PapeteParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.state = 135
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.type_()
                self.state = 69
                self.match(PapeteParser.VAR)
                self.state = 70
                self.match(PapeteParser.T__1)
                self.state = 82
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PapeteParser.INT, PapeteParser.FLOAT, PapeteParser.DOUBLE, PapeteParser.STRING, PapeteParser.BOOL]:
                    self.state = 77 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 71
                        self.type_()
                        self.state = 72
                        self.match(PapeteParser.VAR)
                        self.state = 75
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==PapeteParser.EOL:
                            self.state = 74
                            self.match(PapeteParser.EOL)


                        self.state = 79 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL))) != 0)):
                            break

                    pass
                elif token in [PapeteParser.T__2]:
                    self.state = 81
                    self.match(PapeteParser.T__2)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 84
                self.match(PapeteParser.T__3)
                self.state = 85
                self.match(PapeteParser.OBR)
                self.state = 87 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 86
                    self.cmd()
                    self.state = 89 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 91
                self.retr()
                self.state = 92
                self.match(PapeteParser.CBR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self.match(PapeteParser.VOID)
                self.state = 95
                self.match(PapeteParser.VAR)
                self.state = 96
                self.match(PapeteParser.T__1)
                self.state = 108
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PapeteParser.INT, PapeteParser.FLOAT, PapeteParser.DOUBLE, PapeteParser.STRING, PapeteParser.BOOL]:
                    self.state = 103 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 97
                        self.type_()
                        self.state = 98
                        self.match(PapeteParser.VAR)
                        self.state = 101
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==PapeteParser.EOL:
                            self.state = 100
                            self.match(PapeteParser.EOL)


                        self.state = 105 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL))) != 0)):
                            break

                    pass
                elif token in [PapeteParser.T__2]:
                    self.state = 107
                    self.match(PapeteParser.T__2)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 110
                self.match(PapeteParser.T__3)
                self.state = 111
                self.match(PapeteParser.OBR)
                self.state = 113 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 112
                    self.cmd()
                    self.state = 115 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 117
                self.match(PapeteParser.CBR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 119
                _la = self._input.LA(1)
                if not(_la==PapeteParser.INT or _la==PapeteParser.VOID):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 120
                self.match(PapeteParser.MAIN)
                self.state = 121
                self.match(PapeteParser.T__1)
                self.state = 122
                self.match(PapeteParser.T__2)
                self.state = 123
                self.match(PapeteParser.T__3)
                self.state = 124
                self.match(PapeteParser.OBR)
                self.state = 126 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 125
                    self.cmd()
                    self.state = 128 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 130
                self.match(PapeteParser.RET)
                self.state = 131
                self.match(PapeteParser.T__2)
                self.state = 132
                self.match(PapeteParser.EOL)
                self.state = 133
                self.match(PapeteParser.CBR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CmdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_cmd

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FuncCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncCmd" ):
                listener.enterFuncCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncCmd" ):
                listener.exitFuncCmd(self)


    class InitCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def init_(self):
            return self.getTypedRuleContext(PapeteParser.Init_Context,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitCmd" ):
                listener.enterInitCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitCmd" ):
                listener.exitInitCmd(self)


    class WhileCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def while_(self):
            return self.getTypedRuleContext(PapeteParser.While_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileCmd" ):
                listener.enterWhileCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileCmd" ):
                listener.exitWhileCmd(self)


    class ForCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def for_(self):
            return self.getTypedRuleContext(PapeteParser.For_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForCmd" ):
                listener.enterForCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForCmd" ):
                listener.exitForCmd(self)


    class PrintCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def print_(self):
            return self.getTypedRuleContext(PapeteParser.Print_Context,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintCmd" ):
                listener.enterPrintCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintCmd" ):
                listener.exitPrintCmd(self)


    class AtrCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atr(self):
            return self.getTypedRuleContext(PapeteParser.AtrContext,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtrCmd" ):
                listener.enterAtrCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtrCmd" ):
                listener.exitAtrCmd(self)


    class ReadCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def read(self):
            return self.getTypedRuleContext(PapeteParser.ReadContext,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReadCmd" ):
                listener.enterReadCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReadCmd" ):
                listener.exitReadCmd(self)


    class IfCmdContext(CmdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CmdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ifstmt(self):
            return self.getTypedRuleContext(PapeteParser.IfstmtContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfCmd" ):
                listener.enterIfCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfCmd" ):
                listener.exitIfCmd(self)



    def cmd(self):

        localctx = PapeteParser.CmdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_cmd)
        try:
            self.state = 155
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.AtrCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 137
                self.atr()
                self.state = 138
                self.match(PapeteParser.EOL)
                pass

            elif la_ == 2:
                localctx = PapeteParser.InitCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 140
                self.init_()
                self.state = 141
                self.match(PapeteParser.EOL)
                pass

            elif la_ == 3:
                localctx = PapeteParser.PrintCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 143
                self.print_()
                self.state = 144
                self.match(PapeteParser.EOL)
                pass

            elif la_ == 4:
                localctx = PapeteParser.ReadCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 146
                self.read()
                self.state = 147
                self.match(PapeteParser.EOL)
                pass

            elif la_ == 5:
                localctx = PapeteParser.IfCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 149
                self.ifstmt()
                pass

            elif la_ == 6:
                localctx = PapeteParser.WhileCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 150
                self.while_()
                pass

            elif la_ == 7:
                localctx = PapeteParser.ForCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 151
                self.for_()
                pass

            elif la_ == 8:
                localctx = PapeteParser.FuncCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 152
                self.callfunc()
                self.state = 153
                self.match(PapeteParser.EOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallfuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.VAR)
            else:
                return self.getToken(PapeteParser.VAR, i)

        def NUMINT(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.NUMINT)
            else:
                return self.getToken(PapeteParser.NUMINT, i)

        def NUMDOUBLE(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.NUMDOUBLE)
            else:
                return self.getToken(PapeteParser.NUMDOUBLE, i)

        def getRuleIndex(self):
            return PapeteParser.RULE_callfunc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallfunc" ):
                listener.enterCallfunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallfunc" ):
                listener.exitCallfunc(self)




    def callfunc(self):

        localctx = PapeteParser.CallfuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_callfunc)
        self._la = 0 # Token type
        try:
            self.state = 171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 157
                self.match(PapeteParser.VAR)
                self.state = 158
                self.match(PapeteParser.T__1)
                self.state = 163 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 159
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.VAR) | (1 << PapeteParser.NUMDOUBLE) | (1 << PapeteParser.NUMINT))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 161
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==PapeteParser.T__4:
                        self.state = 160
                        self.match(PapeteParser.T__4)


                    self.state = 165 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.VAR) | (1 << PapeteParser.NUMDOUBLE) | (1 << PapeteParser.NUMINT))) != 0)):
                        break

                self.state = 167
                self.match(PapeteParser.T__3)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 168
                self.match(PapeteParser.VAR)
                self.state = 169
                self.match(PapeteParser.T__1)
                self.state = 170
                self.match(PapeteParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(PapeteParser.WHILE, 0)

        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)


        def OBR(self):
            return self.getToken(PapeteParser.OBR, 0)

        def CBR(self):
            return self.getToken(PapeteParser.CBR, 0)

        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def getRuleIndex(self):
            return PapeteParser.RULE_while_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_" ):
                listener.enterWhile_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_" ):
                listener.exitWhile_(self)




    def while_(self):

        localctx = PapeteParser.While_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_while_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(PapeteParser.WHILE)
            self.state = 174
            self.match(PapeteParser.T__1)
            self.state = 175
            self.cond(0)
            self.state = 176
            self.match(PapeteParser.T__3)
            self.state = 177
            self.match(PapeteParser.OBR)
            self.state = 179 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 178
                self.cmd()
                self.state = 181 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                    break

            self.state = 183
            self.match(PapeteParser.CBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(PapeteParser.FOR, 0)

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.EOL)
            else:
                return self.getToken(PapeteParser.EOL, i)

        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)


        def atr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.AtrContext)
            else:
                return self.getTypedRuleContext(PapeteParser.AtrContext,i)


        def OBR(self):
            return self.getToken(PapeteParser.OBR, 0)

        def CBR(self):
            return self.getToken(PapeteParser.CBR, 0)

        def init_(self):
            return self.getTypedRuleContext(PapeteParser.Init_Context,0)


        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def getRuleIndex(self):
            return PapeteParser.RULE_for_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_" ):
                listener.enterFor_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_" ):
                listener.exitFor_(self)




    def for_(self):

        localctx = PapeteParser.For_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_for_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(PapeteParser.FOR)
            self.state = 186
            self.match(PapeteParser.T__1)
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 187
                self.atr()
                pass

            elif la_ == 2:
                self.state = 188
                self.init_()
                pass


            self.state = 191
            self.match(PapeteParser.EOL)
            self.state = 192
            self.cond(0)
            self.state = 193
            self.match(PapeteParser.EOL)
            self.state = 194
            self.atr()
            self.state = 195
            self.match(PapeteParser.T__3)
            self.state = 196
            self.match(PapeteParser.OBR)
            self.state = 198 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 197
                self.cmd()
                self.state = 200 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                    break

            self.state = 202
            self.match(PapeteParser.CBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfstmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_ifstmt

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NormalIfStmtContext(IfstmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.IfstmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(PapeteParser.IF, 0)
        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)

        def OBR(self):
            return self.getToken(PapeteParser.OBR, 0)
        def CBR(self):
            return self.getToken(PapeteParser.CBR, 0)
        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNormalIfStmt" ):
                listener.enterNormalIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNormalIfStmt" ):
                listener.exitNormalIfStmt(self)


    class NegIfStmtContext(IfstmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.IfstmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(PapeteParser.IF, 0)
        def OBR(self):
            return self.getToken(PapeteParser.OBR, 0)
        def CBR(self):
            return self.getToken(PapeteParser.CBR, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegIfStmt" ):
                listener.enterNegIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegIfStmt" ):
                listener.exitNegIfStmt(self)


    class IfElseIfStmtContext(IfstmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.IfstmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(PapeteParser.IF, 0)
        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)

        def OBR(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.OBR)
            else:
                return self.getToken(PapeteParser.OBR, i)
        def CBR(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.CBR)
            else:
                return self.getToken(PapeteParser.CBR, i)
        def ELSE(self):
            return self.getToken(PapeteParser.ELSE, 0)
        def cmd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.CmdContext)
            else:
                return self.getTypedRuleContext(PapeteParser.CmdContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfElseIfStmt" ):
                listener.enterIfElseIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfElseIfStmt" ):
                listener.exitIfElseIfStmt(self)



    def ifstmt(self):

        localctx = PapeteParser.IfstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ifstmt)
        self._la = 0 # Token type
        try:
            self.state = 252
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.NormalIfStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 204
                self.match(PapeteParser.IF)
                self.state = 205
                self.match(PapeteParser.T__1)
                self.state = 206
                self.cond(0)
                self.state = 207
                self.match(PapeteParser.T__3)
                self.state = 208
                self.match(PapeteParser.OBR)
                self.state = 210 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 209
                    self.cmd()
                    self.state = 212 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 214
                self.match(PapeteParser.CBR)
                pass

            elif la_ == 2:
                localctx = PapeteParser.NegIfStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 216
                self.match(PapeteParser.IF)
                self.state = 217
                self.match(PapeteParser.T__1)
                self.state = 221
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PapeteParser.VAR]:
                    self.state = 218
                    self.match(PapeteParser.VAR)
                    pass
                elif token in [PapeteParser.T__5]:
                    self.state = 219
                    self.match(PapeteParser.T__5)
                    self.state = 220
                    self.match(PapeteParser.VAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 223
                self.match(PapeteParser.T__3)
                self.state = 224
                self.match(PapeteParser.OBR)
                self.state = 226 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 225
                    self.cmd()
                    self.state = 228 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 230
                self.match(PapeteParser.CBR)
                pass

            elif la_ == 3:
                localctx = PapeteParser.IfElseIfStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 232
                self.match(PapeteParser.IF)
                self.state = 233
                self.match(PapeteParser.T__1)
                self.state = 234
                self.cond(0)
                self.state = 235
                self.match(PapeteParser.T__3)
                self.state = 236
                self.match(PapeteParser.OBR)
                self.state = 238 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 237
                    self.cmd()
                    self.state = 240 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 242
                self.match(PapeteParser.CBR)
                self.state = 243
                self.match(PapeteParser.ELSE)
                self.state = 244
                self.match(PapeteParser.OBR)
                self.state = 246 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 245
                    self.cmd()
                    self.state = 248 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.FOR) | (1 << PapeteParser.WHILE) | (1 << PapeteParser.IF) | (1 << PapeteParser.PRINT) | (1 << PapeteParser.INT) | (1 << PapeteParser.FLOAT) | (1 << PapeteParser.DOUBLE) | (1 << PapeteParser.STRING) | (1 << PapeteParser.BOOL) | (1 << PapeteParser.READ) | (1 << PapeteParser.VAR))) != 0)):
                        break

                self.state = 250
                self.match(PapeteParser.CBR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_cond

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class OrCondContext(CondContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CondContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)

        def OR(self):
            return self.getToken(PapeteParser.OR, 0)
        def cdand(self):
            return self.getTypedRuleContext(PapeteParser.CdandContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrCond" ):
                listener.enterOrCond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrCond" ):
                listener.exitOrCond(self)


    class CdandCondContext(CondContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CondContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cdand(self):
            return self.getTypedRuleContext(PapeteParser.CdandContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCdandCond" ):
                listener.enterCdandCond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCdandCond" ):
                listener.exitCdandCond(self)



    def cond(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PapeteParser.CondContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 16
        self.enterRecursionRule(localctx, 16, self.RULE_cond, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = PapeteParser.CdandCondContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 255
            self.cdand(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 262
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,27,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = PapeteParser.OrCondContext(self, PapeteParser.CondContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_cond)
                    self.state = 257
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 258
                    self.match(PapeteParser.OR)
                    self.state = 259
                    self.cdand(0) 
                self.state = 264
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CdandContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_cdand

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class AndCdandContext(CdandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CdandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cdand(self):
            return self.getTypedRuleContext(PapeteParser.CdandContext,0)

        def AND(self):
            return self.getToken(PapeteParser.AND, 0)
        def cndts(self):
            return self.getTypedRuleContext(PapeteParser.CndtsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndCdand" ):
                listener.enterAndCdand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndCdand" ):
                listener.exitAndCdand(self)


    class CndtsCdandContext(CdandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CdandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cndts(self):
            return self.getTypedRuleContext(PapeteParser.CndtsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCndtsCdand" ):
                listener.enterCndtsCdand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCndtsCdand" ):
                listener.exitCndtsCdand(self)



    def cdand(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PapeteParser.CdandContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 18
        self.enterRecursionRule(localctx, 18, self.RULE_cdand, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = PapeteParser.CndtsCdandContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 266
            self.cndts()
            self._ctx.stop = self._input.LT(-1)
            self.state = 273
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,28,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = PapeteParser.AndCdandContext(self, PapeteParser.CdandContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_cdand)
                    self.state = 268
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 269
                    self.match(PapeteParser.AND)
                    self.state = 270
                    self.cndts() 
                self.state = 275
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CndtsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_cndts

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RelopCndtsContext(CndtsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CndtsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PapeteParser.ExprContext)
            else:
                return self.getTypedRuleContext(PapeteParser.ExprContext,i)

        def relop(self):
            return self.getTypedRuleContext(PapeteParser.RelopContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelopCndts" ):
                listener.enterRelopCndts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelopCndts" ):
                listener.exitRelopCndts(self)


    class CondCndtsContext(CndtsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.CndtsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cond(self):
            return self.getTypedRuleContext(PapeteParser.CondContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondCndts" ):
                listener.enterCondCndts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondCndts" ):
                listener.exitCondCndts(self)



    def cndts(self):

        localctx = PapeteParser.CndtsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_cndts)
        try:
            self.state = 284
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.RelopCndtsContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 276
                self.expr(0)
                self.state = 277
                self.relop()
                self.state = 278
                self.expr(0)
                pass

            elif la_ == 2:
                localctx = PapeteParser.CondCndtsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 280
                self.match(PapeteParser.T__1)
                self.state = 281
                self.cond(0)
                self.state = 282
                self.match(PapeteParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRT(self):
            return self.getToken(PapeteParser.GRT, 0)

        def LESS(self):
            return self.getToken(PapeteParser.LESS, 0)

        def GRTEQ(self):
            return self.getToken(PapeteParser.GRTEQ, 0)

        def LESSEQ(self):
            return self.getToken(PapeteParser.LESSEQ, 0)

        def EQ(self):
            return self.getToken(PapeteParser.EQ, 0)

        def NEQ(self):
            return self.getToken(PapeteParser.NEQ, 0)

        def getRuleIndex(self):
            return PapeteParser.RULE_relop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelop" ):
                listener.enterRelop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelop" ):
                listener.exitRelop(self)




    def relop(self):

        localctx = PapeteParser.RelopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_relop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PapeteParser.GRT) | (1 << PapeteParser.LESS) | (1 << PapeteParser.GRTEQ) | (1 << PapeteParser.LESSEQ) | (1 << PapeteParser.EQ) | (1 << PapeteParser.NEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ(self):
            return self.getToken(PapeteParser.READ, 0)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)

        def type_(self):
            return self.getTypedRuleContext(PapeteParser.Type_Context,0)


        def getRuleIndex(self):
            return PapeteParser.RULE_read

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRead" ):
                listener.enterRead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRead" ):
                listener.exitRead(self)




    def read(self):

        localctx = PapeteParser.ReadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_read)
        try:
            self.state = 294
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 288
                self.match(PapeteParser.READ)
                self.state = 289
                self.match(PapeteParser.VAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 290
                self.match(PapeteParser.READ)
                self.state = 291
                self.type_()
                self.state = 292
                self.match(PapeteParser.VAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_print_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VarPrintContext(Print_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Print_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def PRINT(self):
            return self.getToken(PapeteParser.PRINT, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarPrint" ):
                listener.enterVarPrint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarPrint" ):
                listener.exitVarPrint(self)


    class ConcatPrintContext(Print_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Print_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def PRINT(self):
            return self.getToken(PapeteParser.PRINT, 0)
        def STRVALUE(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.STRVALUE)
            else:
                return self.getToken(PapeteParser.STRVALUE, i)
        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(PapeteParser.VAR)
            else:
                return self.getToken(PapeteParser.VAR, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatPrint" ):
                listener.enterConcatPrint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatPrint" ):
                listener.exitConcatPrint(self)



    def print_(self):

        localctx = PapeteParser.Print_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_print_)
        self._la = 0 # Token type
        try:
            self.state = 317
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.ConcatPrintContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 296
                self.match(PapeteParser.PRINT)
                self.state = 297
                self.match(PapeteParser.T__1)
                self.state = 308 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 299
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==PapeteParser.T__6:
                        self.state = 298
                        self.match(PapeteParser.T__6)


                    self.state = 301
                    self.match(PapeteParser.STRVALUE)
                    self.state = 303
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                    if la_ == 1:
                        self.state = 302
                        self.match(PapeteParser.T__6)


                    self.state = 306
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==PapeteParser.VAR:
                        self.state = 305
                        self.match(PapeteParser.VAR)


                    self.state = 310 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==PapeteParser.T__6 or _la==PapeteParser.STRVALUE):
                        break

                self.state = 312
                self.match(PapeteParser.T__3)
                pass

            elif la_ == 2:
                localctx = PapeteParser.VarPrintContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 313
                self.match(PapeteParser.PRINT)
                self.state = 314
                self.match(PapeteParser.T__1)
                self.state = 315
                self.match(PapeteParser.VAR)
                self.state = 316
                self.match(PapeteParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Init_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(PapeteParser.Type_Context,0)


        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)

        def getRuleIndex(self):
            return PapeteParser.RULE_init_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInit_" ):
                listener.enterInit_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInit_" ):
                listener.exitInit_(self)




    def init_(self):

        localctx = PapeteParser.Init_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_init_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.type_()
            self.state = 320
            self.match(PapeteParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_retr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VarRetrContext(RetrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.RetrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RET(self):
            return self.getToken(PapeteParser.RET, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarRetr" ):
                listener.enterVarRetr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarRetr" ):
                listener.exitVarRetr(self)


    class ExprRetrContext(RetrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.RetrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RET(self):
            return self.getToken(PapeteParser.RET, 0)
        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def EOL(self):
            return self.getToken(PapeteParser.EOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRetr" ):
                listener.enterExprRetr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRetr" ):
                listener.exitExprRetr(self)



    def retr(self):

        localctx = PapeteParser.RetrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_retr)
        try:
            self.state = 329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.VarRetrContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 322
                self.match(PapeteParser.RET)
                self.state = 323
                self.match(PapeteParser.VAR)
                self.state = 324
                self.match(PapeteParser.EOL)
                pass

            elif la_ == 2:
                localctx = PapeteParser.ExprRetrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 325
                self.match(PapeteParser.RET)
                self.state = 326
                self.expr(0)
                self.state = 327
                self.match(PapeteParser.EOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_atr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IntAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(PapeteParser.INT, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntAtr" ):
                listener.enterIntAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntAtr" ):
                listener.exitIntAtr(self)


    class BoolAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(PapeteParser.BOOL, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def TRUE(self):
            return self.getToken(PapeteParser.TRUE, 0)
        def FALSE(self):
            return self.getToken(PapeteParser.FALSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolAtr" ):
                listener.enterBoolAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolAtr" ):
                listener.exitBoolAtr(self)


    class StringAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(PapeteParser.STRING, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def STRVALUE(self):
            return self.getToken(PapeteParser.STRVALUE, 0)
        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringAtr" ):
                listener.enterStringAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringAtr" ):
                listener.exitStringAtr(self)


    class DoubleAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLE(self):
            return self.getToken(PapeteParser.DOUBLE, 0)
        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleAtr" ):
                listener.enterDoubleAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleAtr" ):
                listener.exitDoubleAtr(self)


    class VarStrAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def STRVALUE(self):
            return self.getToken(PapeteParser.STRVALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarStrAtr" ):
                listener.enterVarStrAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarStrAtr" ):
                listener.exitVarStrAtr(self)


    class VarBoolAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def TRUE(self):
            return self.getToken(PapeteParser.TRUE, 0)
        def FALSE(self):
            return self.getToken(PapeteParser.FALSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarBoolAtr" ):
                listener.enterVarBoolAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarBoolAtr" ):
                listener.exitVarBoolAtr(self)


    class VarExprFuncAtrContext(AtrContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.AtrContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)
        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def callfunc(self):
            return self.getTypedRuleContext(PapeteParser.CallfuncContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarExprFuncAtr" ):
                listener.enterVarExprFuncAtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarExprFuncAtr" ):
                listener.exitVarExprFuncAtr(self)



    def atr(self):

        localctx = PapeteParser.AtrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_atr)
        self._la = 0 # Token type
        try:
            self.state = 368
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                localctx = PapeteParser.IntAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 331
                self.match(PapeteParser.INT)
                self.state = 332
                self.match(PapeteParser.VAR)
                self.state = 333
                self.match(PapeteParser.T__7)
                self.state = 336
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                if la_ == 1:
                    self.state = 334
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 335
                    self.callfunc()
                    pass


                pass

            elif la_ == 2:
                localctx = PapeteParser.DoubleAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 338
                self.match(PapeteParser.DOUBLE)
                self.state = 339
                self.match(PapeteParser.VAR)
                self.state = 340
                self.match(PapeteParser.T__7)
                self.state = 343
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
                if la_ == 1:
                    self.state = 341
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 342
                    self.callfunc()
                    pass


                pass

            elif la_ == 3:
                localctx = PapeteParser.StringAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 345
                self.match(PapeteParser.STRING)
                self.state = 346
                self.match(PapeteParser.VAR)
                self.state = 347
                self.match(PapeteParser.T__7)
                self.state = 350
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PapeteParser.STRVALUE]:
                    self.state = 348
                    self.match(PapeteParser.STRVALUE)
                    pass
                elif token in [PapeteParser.VAR]:
                    self.state = 349
                    self.callfunc()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                localctx = PapeteParser.BoolAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 352
                self.match(PapeteParser.BOOL)
                self.state = 353
                self.match(PapeteParser.VAR)
                self.state = 354
                self.match(PapeteParser.T__7)
                self.state = 355
                _la = self._input.LA(1)
                if not(_la==PapeteParser.TRUE or _la==PapeteParser.FALSE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 5:
                localctx = PapeteParser.VarExprFuncAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 356
                self.match(PapeteParser.VAR)
                self.state = 357
                self.match(PapeteParser.T__7)
                self.state = 360
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
                if la_ == 1:
                    self.state = 358
                    self.expr(0)
                    pass

                elif la_ == 2:
                    self.state = 359
                    self.callfunc()
                    pass


                pass

            elif la_ == 6:
                localctx = PapeteParser.VarStrAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 362
                self.match(PapeteParser.VAR)
                self.state = 363
                self.match(PapeteParser.T__7)

                self.state = 364
                self.match(PapeteParser.STRVALUE)
                pass

            elif la_ == 7:
                localctx = PapeteParser.VarBoolAtrContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 365
                self.match(PapeteParser.VAR)
                self.state = 366
                self.match(PapeteParser.T__7)
                self.state = 367
                _la = self._input.LA(1)
                if not(_la==PapeteParser.TRUE or _la==PapeteParser.FALSE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TermExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermExpr" ):
                listener.enterTermExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermExpr" ):
                listener.exitTermExpr(self)


    class SumExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSumExpr" ):
                listener.enterSumExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSumExpr" ):
                listener.exitSumExpr(self)


    class MinusExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinusExpr" ):
                listener.enterMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinusExpr" ):
                listener.exitMinusExpr(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PapeteParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_expr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = PapeteParser.TermExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 371
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 381
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 379
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                    if la_ == 1:
                        localctx = PapeteParser.SumExprContext(self, PapeteParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 373
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 374
                        self.match(PapeteParser.T__6)
                        self.state = 375
                        self.term(0)
                        pass

                    elif la_ == 2:
                        localctx = PapeteParser.MinusExprContext(self, PapeteParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 376
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 377
                        self.match(PapeteParser.T__8)
                        self.state = 378
                        self.term(0)
                        pass

             
                self.state = 383
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_term

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class FactTermContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fact(self):
            return self.getTypedRuleContext(PapeteParser.FactContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactTerm" ):
                listener.enterFactTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactTerm" ):
                listener.exitFactTerm(self)


    class MultTermContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)

        def fact(self):
            return self.getTypedRuleContext(PapeteParser.FactContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultTerm" ):
                listener.enterMultTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultTerm" ):
                listener.exitMultTerm(self)


    class DivTermContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)

        def fact(self):
            return self.getTypedRuleContext(PapeteParser.FactContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDivTerm" ):
                listener.enterDivTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDivTerm" ):
                listener.exitDivTerm(self)


    class RestTermContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(PapeteParser.TermContext,0)

        def fact(self):
            return self.getTypedRuleContext(PapeteParser.FactContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestTerm" ):
                listener.enterRestTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestTerm" ):
                listener.exitRestTerm(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PapeteParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_term, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = PapeteParser.FactTermContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 385
            self.fact()
            self._ctx.stop = self._input.LT(-1)
            self.state = 398
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 396
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                    if la_ == 1:
                        localctx = PapeteParser.MultTermContext(self, PapeteParser.TermContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                        self.state = 387
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 388
                        self.match(PapeteParser.T__9)
                        self.state = 389
                        self.fact()
                        pass

                    elif la_ == 2:
                        localctx = PapeteParser.DivTermContext(self, PapeteParser.TermContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                        self.state = 390
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 391
                        self.match(PapeteParser.T__10)
                        self.state = 392
                        self.fact()
                        pass

                    elif la_ == 3:
                        localctx = PapeteParser.RestTermContext(self, PapeteParser.TermContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                        self.state = 393
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 394
                        self.match(PapeteParser.T__11)
                        self.state = 395
                        self.fact()
                        pass

             
                self.state = 400
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_fact

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NumDoubleFactContext(FactContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.FactContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMDOUBLE(self):
            return self.getToken(PapeteParser.NUMDOUBLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumDoubleFact" ):
                listener.enterNumDoubleFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumDoubleFact" ):
                listener.exitNumDoubleFact(self)


    class NumIntFactContext(FactContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.FactContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMINT(self):
            return self.getToken(PapeteParser.NUMINT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumIntFact" ):
                listener.enterNumIntFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumIntFact" ):
                listener.exitNumIntFact(self)


    class ExprFactContext(FactContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.FactContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(PapeteParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprFact" ):
                listener.enterExprFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprFact" ):
                listener.exitExprFact(self)


    class VarFactContext(FactContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.FactContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(PapeteParser.VAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarFact" ):
                listener.enterVarFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarFact" ):
                listener.exitVarFact(self)



    def fact(self):

        localctx = PapeteParser.FactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_fact)
        self._la = 0 # Token type
        try:
            self.state = 408
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PapeteParser.VAR]:
                localctx = PapeteParser.VarFactContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 401
                self.match(PapeteParser.VAR)
                pass
            elif token in [PapeteParser.NUMDOUBLE]:
                localctx = PapeteParser.NumDoubleFactContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 402
                self.match(PapeteParser.NUMDOUBLE)
                pass
            elif token in [PapeteParser.T__2, PapeteParser.NUMINT]:
                localctx = PapeteParser.NumIntFactContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 403
                _la = self._input.LA(1)
                if not(_la==PapeteParser.T__2 or _la==PapeteParser.NUMINT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PapeteParser.T__1]:
                localctx = PapeteParser.ExprFactContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 404
                self.match(PapeteParser.T__1)
                self.state = 405
                self.expr(0)
                self.state = 406
                self.match(PapeteParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PapeteParser.RULE_type_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DoubleTypeContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLE(self):
            return self.getToken(PapeteParser.DOUBLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleType" ):
                listener.enterDoubleType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleType" ):
                listener.exitDoubleType(self)


    class FloatTypeContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def FLOAT(self):
            return self.getToken(PapeteParser.FLOAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatType" ):
                listener.enterFloatType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatType" ):
                listener.exitFloatType(self)


    class IntTypeContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(PapeteParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntType" ):
                listener.enterIntType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntType" ):
                listener.exitIntType(self)


    class StringTypeContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(PapeteParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringType" ):
                listener.enterStringType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringType" ):
                listener.exitStringType(self)


    class BoolTypeContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a PapeteParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(PapeteParser.BOOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolType" ):
                listener.enterBoolType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolType" ):
                listener.exitBoolType(self)



    def type_(self):

        localctx = PapeteParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_type_)
        try:
            self.state = 415
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PapeteParser.INT]:
                localctx = PapeteParser.IntTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 410
                self.match(PapeteParser.INT)
                pass
            elif token in [PapeteParser.DOUBLE]:
                localctx = PapeteParser.DoubleTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 411
                self.match(PapeteParser.DOUBLE)
                pass
            elif token in [PapeteParser.FLOAT]:
                localctx = PapeteParser.FloatTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 412
                self.match(PapeteParser.FLOAT)
                pass
            elif token in [PapeteParser.STRING]:
                localctx = PapeteParser.StringTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 413
                self.match(PapeteParser.STRING)
                pass
            elif token in [PapeteParser.BOOL]:
                localctx = PapeteParser.BoolTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 414
                self.match(PapeteParser.BOOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[8] = self.cond_sempred
        self._predicates[9] = self.cdand_sempred
        self._predicates[17] = self.expr_sempred
        self._predicates[18] = self.term_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def cond_sempred(self, localctx:CondContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def cdand_sempred(self, localctx:CdandContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         




